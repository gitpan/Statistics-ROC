.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH ROC 3 "perl 5.005, patch 03" "13/Jan/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Statistics::ROC \- receiver-operator-characteristic (ROC) curves with nonparametric confidence bounds
.SH "SYNOPSIS"
.PP
.Vb 1
\&  use Statistics::ROC;
.Ve
.Vb 8
\&  my ($y)    = loggamma($x);
\&  my ($y)    = betain($x, $p, $q, $beta);
\&  my ($y)    = Betain($x, $p, $q);
\&  my ($y)    = xinbta($p, $q, $beta, $alpha);
\&  my ($y)    = Xinbta($p, $q, $alpha);
\&  my (@rk)   = rank($type, \e@r);
\&  my (@ROC)  = roc($model_type,$conf,\e@val_grp);
\&  
.Ve
.SH "DESCRIPTION"
This program determines the ROC curve and its nonparametric confidence bounds for
data categorized into two groups.
A ROC curve shows the relationship of \fBprobability of false alarm\fR (x-axis) to 
\fBprobability of detection\fR (y-axis) for a certain test.
Expressed in medical terms: the \fBprobability of a positive test, given no disease\fR
to the \fBprobability of a positive test, given disease\fR.
The ROC curve may be used to determine an \fIoptimal\fR cutoff point for the test.
.PP
The main function is \fBroc()\fR. The other exported functions are used by \fBroc()\fR, but
might be useful for other nonparametric statistical procedures.
.Ip "\fBloggamma\fR" 4
This procedure evaluates the natural logarithm of \fIgamma\fR\|(x) for all
x>0, accurate to 10 decimal places. Stirlings formula is used for the
central polynomial part of the procedure. 
For \f(CWx=0\fR a value of  743.746924740801 will be returned: this is 
\fIloggamma\fR\|(9.9999999999E\-324).
.Ip "\fBbetain\fR" 4
Computes incomplete beta function ratio 
.Sp
.Vb 3
\&    Remarks:
\&    Complete beta function: B(p,q)=gamma(p)*gamma(q)/gamma(p+q)
\&                       log(B(p,q))=ln(gamma(p))+ln(gamma(q))-ln(gamma(p+q))
.Ve
.Vb 2
\&    Incomplete beta function ratio:
\&                 I_x(p,q)=1/B(p,q) * \eint_0^x t^{p-1}*(1-t)^{q-1} dt
.Ve
.Vb 8
\&    --> log(B(p,q)) has to be supplied to calculate I_x(p,q)
\&    log denotes the natural logarithm
\&        $beta = log(B(p,q))
\&        $x    = x
\&        $p    = p
\&        $q    = q
\&    The subroutine returns I_x(p,q). If an error occurs a negative value 
\&    {-1,-2} is returned.
.Ve
.Ip "\fBBetain\fR " 4
Computes the incomplete beta function by calling \fBloggamma()\fR and \fBbetain()\fR.
.Ip "\fBxinbta\fR " 4
Computes inverse of incomplete beta function ratio
.Sp
.Vb 4
\&    Remarks:
\& 
\&    Complete beta function: B(p,q)=gamma(p)*gamma(q)/gamma(p+q)
\&                       log(B(p,q))=ln(gamma(p))+ln(gamma(q))-ln(gamma(p+q))
.Ve
.Vb 2
\&    Incomplete beta function ratio:
\&              alpha = I_x(p,q) = 1/B(p,q) * \eint_0^x t^{p-1}*(1-t)^{q-1} dt
.Ve
.Vb 9
\&    --> log(B(p,q)) has to be supplied to calculate I_x(p,q)
\&    log denotes the natural logarithm
\&        $beta = log(B(p,q))
\&        $alpha= I_x(p,q)
\&        $p    = p
\&        $q    = q
\&    The subroutine returns x. If an error occurs a negative value {-1,-2,-3}
\&    is returned.
\&      
.Ve
.Ip "\fBXinbta\fR" 4
Computes the inverse of the incomplete beta function by calling \fBloggamma()\fR 
and \fBxinbta()\fR.
.Ip "\fBrank\fR" 4
Computes the ranks of the values specified as the second argument (an array). 
Returns a vector of ranks corresponding to the input vector.
Different types of ranking are possible ('high\*(R', \*(L'low\*(R', \*(L'mean'), and are 
specified as first argument. These differ in the way ties of the input vector, 
i.e. identical values, are treated: 
.Ip "\(bu \fBhigh\fR: " 14
replace ranks of identical values with their highest rank
       
.Ip "\(bu \fBlow\fR:   " 14
replace ranks of identical values with their lowest rank
       
.Ip "\(bu \fBmean\fR:" 14
replace ranks of identical values with the mean of their ranks
.Ip "\fBroc\fR" 4
Determines the \s-1ROC\s0 curve and its nonparametric confidence bounds.
The \s-1ROC\s0 curve shows the relationship of \*(L"probability of false
alarm\*(R" (x-axis) to \*(L"probability of detection\*(R" (y-axis) for a 
certain test.
Or in medical terms: the \*(L"probability of a positive test, given no 
disease\*(R" to the \*(L"probability of a positive test, given disease\*(R".
The \s-1ROC\s0 curve may be used to determine an \*(L"optimal\*(R" cutoff
point for the test.
.Sp
The routine takes three arguments:
.Sp
(1) type of model: \*(L'decrease\*(R' or \*(L'increase\*(R', this states the assumption
that a higher ('increase') value of the data tends to be an 
indicator of a positive test result or for the model \*(L'decrease\*(R'
a lower value.
.Sp
(2) two-sided confidence interval (usually 0.95 is chosen).
.Sp
(3) the data stored as a list-of-lists:
each entry in this list consits of an \*(L"value / true group\*(R" pair, 
i.e. value / disease present. Group values are from {0,1}.
0 stands for disease (or signal) not present (prior knowledge) and
1 for disease (or signal) present (prior knowledge).
Example: \f(CW@s\fR=([2, 0], [12.5, 1], [3, 0], [10, 1], [9.5, 0], [9, 1]);
Notice the small overlap of the groups. The
optimal cutoff point to separate the two groups would be between
9 and 9.5 if the criterion of optimality is to maximize the
probability of detection and simultaneously minimize the 
probability of false alarm.
.Sp
Returns a list-of-lists with the three curves:
      \f(CW@ROC\fR=([@lower_b], [@roc], [@upper_b]) each of the curves is
      again a list-of-lists with each entry consisting of one (x,y) pair.
.Sh "Examples"
.Sp
.Vb 8
\&   $,=" ";
\&   print loggamma(10), "\en";
\&   print Xinbta(3,4,Betain(.6,3,4)),"\en";
\&   
\&   @e=(0.7, 0.7, 0.9, 0.6, 1.0, 1.1, 1,.7,.6);
\&   print rank('low',@e),"\en";
\&   print rank('high',@e),"\en";
\&   print rank('mean',@e),"\en";
.Ve
.Vb 4
\&   @var_grp=([1.5,0],[1.4,0],[1.4,0],[1.3,0],[1.2,0],[1,0],[0.8,0],
\&          [1.1,1],[1,1],[1,1],[0.9,1],[0.7,1],[0.7,1],[0.6,1]);
\&   @curves=roc('decrease',0.95,@var_grp);
\&   print "$curves[0][2][0]  $curves[0][2][1] \en";
.Ve
.SH "AUTHOR"
Hans A. Kestler,  \fIhans.kestler@medizin.uni-ulm.de\fR     \fBor\fR 
\fIh.kestler@ieee.org\fR
.SH "SEE ALSO"
Perl/Tk userinterface for drawing ROC curves (to be uploaded shortly).
.Sp
R.A. Hilgers, Distribution-Free Confidence Bounds for ROC Curves (1991), 
\fIMeth Inform Med\fR, 30:96-101
.Sp
Algorithm 291, Logarithm of the gamma function. 
\fICollected Algorithms of the ACM\fR, Vol II, 1980
     
.Sp
\fINumerical Recipes in C\fR, second edition, by Press, Teukolsky, Vetterling and Flannery,
Cambridge University Press, 1992.
.Sp
G.W. Cran, K.J. Martin and G.E. Thomas (1977).Remark AS R19 and 
Algorithm AS109, A Remark on Algorithms AS 63: The Incomplete Beta Integral
AS 64: Inverse of the Incomplete Beta Function Ratio, 
\fIAppl Statist\fR, 26:111-114.
.Sp
K.J. Berry, P.W. Mielke, Jr and G.W. Cran (1990) Algorithm AS R83, A Remark
on Algorithm AS 109: Inverse of the Incomplete Beta Function Ratio,
\fIAppl Statist\fR, 39:309-310. 

.rn }` ''
.IX Title "ROC 3"
.IX Name "Statistics::ROC - receiver-operator-characteristic (ROC) curves with nonparametric confidence bounds"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\fBloggamma\fR"

.IX Item "\fBbetain\fR"

.IX Item "\fBBetain\fR "

.IX Item "\fBxinbta\fR "

.IX Item "\fBXinbta\fR"

.IX Item "\fBrank\fR"

.IX Item "\(bu \fBhigh\fR: "

.IX Item "\(bu \fBlow\fR:   "

.IX Item "\(bu \fBmean\fR:"

.IX Item "\fBroc\fR"

.IX Subsection "Examples"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

